<?php/* * Copyright (c) 2011-2012, Valdirene da Cruz Neves Júnior <linkinsystem666@gmail.com> * All rights reserved. *//** * Ler os comentários de uma classe utilizados como anotação e retorna como objeto *  * @author		Valdirene da Cruz Neves Júnior <linkinsystem666@gmail.com> * @version 	1.1 * */ class Annotation{	/**	 * Guarda o nome da classe a ser analisada	 * @var	string	 */	private $classname;		/**	 * Guarda as instâncias das classes analisadas	 * @var	array	 */	private static $instances = array();		/**	 * Construtor, recebe o nome de uma classe como parâmetro. É privado por que a classe utilizada o padrão Singleton	 * @param	string	$class			nome da classe a ser analisada	 * @throws	ClassNotFoundException	é disparada caso a classe informada como parâmetro não exista	 */	private function __construct($class)	{		if(!class_exists($class))			throw new ClassNotFoundException($class);		$this->classname = $class;	}		/**	 * Método retorna uma instância da classe Annotation, seguindo o padrão Singleton	 * @param	string	$class	nome da classe a ser analisada	 * @return	object			retorn uma instância da classe Annotation	 */	public static function get($class)	{		if(!isset(self::$instances[$class]))			self::$instances[$class] = new self($class);		return self::$instances[$class];	}		/**	 * Pega a anotação da classe que está sendo analisada	 * @return	object	retorna uma instância de sdtClass	 */	public function getClass()	{		$key = 'Trilado.Annotation.Class.'. $this->classname;				$cache = Cache::factory();		if(Cache::enabled() && $cache->has($key))			return $cache->read($key);				$reflection = new ReflectionClass($this->classname);		$comment = $reflection->getDocComment();		$annotation = $this->extractAnnotation($comment);		if(Cache::enabled())			$cache->write($key, $annotation, CACHE_TIME);		return $annotation;	}		/**	 * Pega a anotação da propriedade passada como parâmetro	 * @param	string	$property			nome da propriedade a ser analisada	 * @throws	PropertyNotFoundException	dispara caso a propriedade não exista na classe	 * @return	object						retorna uma instância de stdClass	 */	public function getProperty($property)	{		if(!property_exists($this->classname, $property))			throw new PropertyNotFoundException($this->classname .'->'. $property);				$key = 'Trilado.Annotation.Property.'. $this->classname.'->'. $property;				$cache = Cache::factory();		if(Cache::enabled() && $cache->has($key))			return $cache->read($key);				$reflection = new ReflectionProperty($this->classname, $property);		$comment = $reflection->getDocComment();		$annotation =  $this->extractAnnotation($comment);		if(Cache::enabled())			$cache->write($key, $annotation, CACHE_TIME);		return $annotation;	}		/**	 * Pega a anotação todas as propriedades da classe	 * @return	array	lista com instâncias de sdtClass	 */	public function getProperties()	{		$key = 'Trilado.Annotation.Properties.'. $this->classname;				$cache = Cache::factory();		if(Cache::enabled() && $cache->has($key))			return $cache->read($key);		$reflection = new ReflectionClass($this->classname);		$properties = array();		foreach($reflection->getProperties(ReflectionProperty::IS_PUBLIC) as $property)		{			$reflectionProperty = new ReflectionProperty($this->classname, $property->getName());			$comment = $reflectionProperty->getDocComment();			$properties[$property->getName()] = $this->extractAnnotation($comment);		}		if(Cache::enabled())			$cache->write($key, $properties, CACHE_TIME);		return $properties;	}		/**	 * Pega a anotação do método especificado	 * @param	string	$method			nome do método a ser analisado	 * @throws	MethodNotFoundException	dispara se o método não existir na classe	 * @return	object					retorna uma instância de stdClass	 */	public function getMethod($method)	{		if(!method_exists($this->classname, $method)) 			throw new MethodNotFoundException($this->classname .'->'. $method .'()');				$key = 'Trilado.Annotation.Method.'. $this->classname .'->'. $method .'()';				$cache = Cache::factory();		if(Cache::enabled() && $cache->has($key))			return $cache->read($key);				$reflection = new ReflectionMethod($this->classname, $method);		$comment = $reflection->getDocComment();		$annotation =  $this->extractAnnotation($comment);		if(Cache::enabled())			$cache->write($key, $annotation, CACHE_TIME);		return $annotation;	}		/**	 * Extrai a anotação a partir de DocComment	 * @param	string	$comment	comentário da documentação	 * @return	object				retorna uma instância de stdClass	 */	private function extractAnnotation($comment)	{		$matches = array();		$annotation = new stdClass;				if(preg_match_all('/@([a-zA-Z]+)\((.*)\)/', $comment, $matches))		{			foreach($matches[1] as $k => $v)			{				if(preg_match('/^"([a-zA-ZÀ-ú0-9_]+)"$/', $matches[2][$k]))				{					$annotation->{$v} = trim($matches[2][$k],'"');				}				else if(preg_match('/^"([a-zA-Z0-9\,\"\*]+)"$/', $matches[2][$k], $sub_matches))				{					$annotation->{$v} = explode('","', $sub_matches[1]);				}				else				{					$annotation->{$v} = new stdClass;					if($matches[2][$k])					{						$attrs = explode('",', $matches[2][$k]);						foreach($attrs as $a)						{							if(strpos($a, '="') !== false)							{								list($property, $value) = explode('="', $a, 2);								$annotation->{$v}->{trim($property)} = str_replace('"', '', $value);							}						}					}				}			}		}		return $annotation;	}}